namespace LibPacketGremlinTests.Packets
{
    using System.IO;
    using System.Linq;

    using FluentAssertions;

    using OutbreakLabs.LibPacketGremlin.Packets;
    using OutbreakLabs.LibPacketGremlin.Packets.IPv4Support;

    using Xunit;
    using OutbreakLabs.LibPacketGremlin.PacketFactories;
    using OutbreakLabs.LibPacketGremlin.Extensions;
    using OutbreakLabs.LibPacketGremlin.Abstractions;
    using OutbreakLabs.LibPacketGremlin.Utilities;

    public class IPv4Tests
    {
        [Fact]
        public void ParsesBasicFields()
        {
            byte[] rawBytes = {0x45, 0x00, 0x00, 0x50, 0x00, 0x00, 0x40, 0x00, 0x40, 0x11
            , 0xb6, 0xce, 0xc0, 0xa8, 0x01, 0x03, 0xc0, 0xa8, 0x01, 0x7b, 0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f};

            IPv4 packet;
            var parseResult = IPv4Factory.Instance.TryParse(rawBytes, out packet);

            parseResult.Should().BeTrue();

            ((int)packet.Version).Should().Be(4);
            ((int)packet.HeaderLength).Should().Be(5);
            packet.DifferentiatedServices.Should().Be(0);
            packet.TotalLength.Should().Be(80);
            packet.ID.Should().Be(0);
            packet.ReservedFlag.Should().Be(false);
            packet.DontFragmentFlag.Should().Be(true);
            packet.MoreFragmentsFlag.Should().Be(false);
            packet.FragOff.Should().Be(0);
            packet.TTL.Should().Be(64);
            packet.Protocol.Should().Be(17);
            packet.HeaderChecksum.Should().Be(46798);
            packet.SourceAddress.Should().Be(IPv4Address.Parse("192.168.1.3"));
            packet.DestAddress.Should().Be(IPv4Address.Parse("192.168.1.123"));

        }

        [Fact]
        public void SerializesCorrectly()
        {
            IPv4 packet;
            IPv4Factory.Instance.TryParse(new byte[] {0x45, 0x00, 0x00, 0x50, 0x00, 0x00, 0x40, 0x00, 0x40, 0x11
            , 0xb6, 0xce, 0xc0, 0xa8, 0x01, 0x03, 0xc0, 0xa8, 0x01, 0x7b, 0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f}, out packet).Should().BeTrue();


            using (var ms = new MemoryStream())
            {
                packet.WriteToStream(ms);
                ms.ToArray()
                    .SequenceEqual(
                        new byte[]
                            {0x45, 0x00, 0x00, 0x50, 0x00, 0x00, 0x40, 0x00, 0x40, 0x11
            , 0xb6, 0xce, 0xc0, 0xa8, 0x01, 0x03, 0xc0, 0xa8, 0x01, 0x7b, 0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f})
                    .Should()
                    .BeTrue();
            }
        }

        [Fact]
        public void CorrectsChecksum()
        {
            byte[] rawBytes = {0x45, 0x00, 0x00, 0x50, 0x00, 0x00, 0x40, 0x00, 0x40, 0x11
            , 0xb6, 0xcf, 0xc0, 0xa8, 0x01, 0x03, 0xc0, 0xa8, 0x01, 0x7b, 0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f};

            IPv4 packet;
            var parseResult = IPv4Factory.Instance.TryParse(rawBytes, out packet);

            parseResult.Should().BeTrue();

            packet.HeaderChecksum.Should().NotBe(46798); // Just making sure our test is valid
            packet.CorrectFields();
            packet.HeaderChecksum.Should().Be(46798);

        }

        [Fact]
        public void CalculatesLength()
        {
            byte[] rawBytes = {0x45, 0x00, 0x00, 0x50, 0x00, 0x00, 0x40, 0x00, 0x40, 0x11
            , 0xb6, 0xce, 0xc0, 0xa8, 0x01, 0x03, 0xc0, 0xa8, 0x01, 0x7b, 0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f};

            IPv4 packet;
            var parseResult = IPv4Factory.Instance.TryParse(rawBytes, out packet);

            parseResult.Should().BeTrue();

            packet.Length().Should().Be(packet.ToArray().Length);

        }

        [Fact]
        public void ChainsToTCP()
        {
            byte[] rawBytes = System.IO.File.ReadAllBytes(Path.Combine("Resources", "msmon80211tcp.bin"));
            IPacket encryptedPacket;
            var parsed = MSMon802_11Factory.Instance.TryParse(rawBytes, out encryptedPacket);
            IPacket decrypted;
            IEEE802_11Crypto.TryDecryptWEP(encryptedPacket.Layer<IEEE802_11>(), new byte[] { 0xC5, 0x8D, 0xB1, 0x5E, 0x2B }, out decrypted);
            decrypted.Layer<TCP>().Should().NotBeNull();
        }
    }
}
