namespace LibPacketGremlinTests.Packets
{
    using System.IO;
    using System.Linq;

    using FluentAssertions;

    using OutbreakLabs.LibPacketGremlin.Packets;
    using OutbreakLabs.LibPacketGremlin.Extensions;

    using Xunit;
    using OutbreakLabs.LibPacketGremlin.PacketFactories;
    using OutbreakLabs.LibPacketGremlin.Packets.IPv4Support;
    public class UDPTests
    {
        [Fact]
        public void ParsesBasicFields()
        {
            byte[] rawBytes = {0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f};

            UDP packet;
            var parseResult = UDPFactory.Instance.TryParse(rawBytes, out packet);

            parseResult.Should().BeTrue();


            packet.SourcePort.Should().Be(32781);
            packet.DestPort.Should().Be(61696);
            packet.TotalLength.Should().Be(60);
            packet.Checksum.Should().Be(35089);

        }

        [Fact]
        public void SerializesCorrectly()
        {
            UDP packet;
            UDPFactory.Instance.TryParse(new byte[] {0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f}, out packet).Should().BeTrue();


            using (var ms = new MemoryStream())
            {
                packet.WriteToStream(ms);
                ms.ToArray()
                    .SequenceEqual(
                        new byte[]
                            {0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f})
                    .Should()
                    .BeTrue();
            }
        }

        [Fact]
        public void CorrectsFields()
        {
            // This test is poor. It seems the original test for CorrectFields didn't set an IPv4 parent, and thus was basically worthless.

            EthernetII packet;
            EthernetIIFactory.Instance.TryParse(new byte[]
                                              {
                                                  0x64, 0x70, 0x02, 0xd1, 0x9e, 0x6f, 0x00, 0x23, 0x54, 0x80, 0xb3, 0xca, 0x08, 0x00, 0x45, 0x00, 0x00, 0x21, 0x2d, 0x57, 0x00, 0x00, 0x80, 0x11, 0x80, 0xbd, 0xc0, 0xa8, 0x05, 0x68, 0xc0, 0xa8, 0x05, 0xff, 0x22, 0xb9, 0x22, 0xb9, 0x00, 0x0d, 0x80, 0x30, 0x02, 0xe1, 0x69, 0x98, 0x41,

                                              }, out packet).Should().BeTrue();

            var ip = (IPv4<UDP>)packet.Payload;
            ip.Payload.Checksum.Should().Be(0x8030);
            packet.CorrectFields();
            ip.Payload.Checksum.Should().Be(0x8030);
            ip.DestAddress = IPv4Address.Parse("192.168.3.101");
            packet.CorrectFields();
            ip.Payload.Checksum.Should().Be(0x82ca);
        }

        [Fact]
        public void CalculatesLength()
        {
            byte[] rawBytes = {0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f};

            UDP packet;
            var parseResult = UDPFactory.Instance.TryParse(rawBytes, out packet);

            parseResult.Should().BeTrue();

            packet.Length().Should().Be(packet.ToArray().Length);

        }
    }
}
