namespace LibPacketGremlinTests.Packets
{
    using System.IO;
    using System.Linq;

    using FluentAssertions;

    using OutbreakLabs.LibPacketGremlin.Packets;
    using OutbreakLabs.LibPacketGremlin.Extensions;

    using Xunit;

    public class UDPTests
    {
        [Fact]
        public void ParsesBasicFields()
        {
            byte[] rawBytes = {0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f};

            UDP packet;
            var parseResult = UDP.TryParse(rawBytes, out packet);

            parseResult.Should().BeTrue();

            
            packet.SourcePort.Should().Be(32781);
            packet.DestPort.Should().Be(61696);
            packet.TotalLength.Should().Be(60);
            packet.Checksum.Should().Be(35089);
            
        }

        [Fact]
        public void SerializesCorrectly()
        {
            UDP packet;
            UDP.TryParse(new byte[] {0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f}, out packet).Should().BeTrue();

            
            using (var ms = new MemoryStream())
            {
                packet.WriteToStream(ms);                
                ms.ToArray()
                    .SequenceEqual(
                        new byte[]
                            {0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f})
                    .Should()
                    .BeTrue();
            }
        }

        [Fact]
        public void DoesNotUnCorrectFields()
        {
            // This test is poor. It seems the original test for CorrectFields didn't set an IPv4 parent, and thus was basically worthless.

            UDP packet;
            UDP.TryParse(new byte[] {0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f}, out packet).Should().BeTrue();

            packet.CorrectFields();
            using (var ms = new MemoryStream())
            {
                packet.WriteToStream(ms);
                ms.ToArray()
                    .SequenceEqual(
                        new byte[]
                            {0x80, 0x0d,
            0xf1, 0x00, 0x00, 0x3c, 0x89, 0x11, 0xec, 0x14, 0x61, 0x11, 0x00, 0x00,
            0x00, 0xfe, 0x09, 0x65, 0x1b, 0xbb, 0x9f, 0xa2, 0x70, 0x43, 0x74, 0x90,
            0x9c, 0x29, 0x13, 0xbb, 0x34, 0x92, 0x14, 0x27, 0x25, 0xdf, 0x1b, 0x8f,
            0x9f, 0xd8, 0xb7, 0xc4, 0xc5, 0xa6, 0x07, 0x36, 0xca, 0xce, 0x11, 0x3b,
            0x32, 0xcd, 0x87, 0x1c, 0x24, 0x2d, 0xad, 0x15, 0xc4, 0x0f})
                    .Should()
                    .BeTrue();
            }
        }
    }
}
